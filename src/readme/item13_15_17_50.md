## ITEM 13 : clone 재정의는 주의해서 진행하라

- clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼지지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.
- 배열을 복제할 때는 배열의 clone 메서드를 사용하라고 권장한다.

### 핵심정리
기본원칙은 '복제 기능은 생성자와 팩터리를 이용하는게 최고'라는 것이다. 단, 배열만은 clone 메서드 방식이 가장 깔끔한, 이 규칙의 합당한 예외라 할 수 있다.

## ITEM 15 : 클래스와 멤버의 접근 권한을 최소화하라

- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다. 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는
전혀 개의치 않는다.
- 정보 은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.

**정보은닉의 장점**

- 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
- 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 떄문이다.
- 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.
- 소프트웨어 재사용성을 높인다.
- 큰 시스템을 제작하는 난이도를 낮춰준다.

**모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.**

## ITEM 17 : 변경 가능성을 최소화하라

**클래스를 불변으로 만드는 다섯 가지 규칙**
- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
- 모든 필드를 final로 선언한다.
- 모든 필드를 private으로 선언한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

## ITEM 50 : 적시에 방어적 복사본을 만들라

- 클라이언트가 여러분의 불변식을 꺠뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 한다.
- 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사 해야 한다.
- 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.

### 핵심정리
클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 스 요소는 받드시 방어적으로 복사해야 한다.
복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 떄의 책임이
클라이언트에 있음을 문서에 명시하도록 하자.
